import { DeclarationBlock } from 'DeclarationBlock';
import { FileParser, PostParseInfo } from 'FileParser';
import { asNoteID, FullID } from 'FullID';
import { Editor, Keymap, PaneType, Plugin, TFile } from 'obsidian';
import { ReviewView } from 'ReviewView';
import { Scheduler } from 'Scheduler';
import { PluginSettings, SettingsManager, SettingTab } from 'Settings';
import { Statistics, StatisticsRoot } from 'Statistics';
import { PLUGIN_ICON, UIAssistant } from 'UIAssistant';

interface PluginData {
	settings: PluginSettings;
	data: StatisticsRoot;
}

export default class ComeThroughPlugin extends Plugin {
	private data: PluginData;
	private settingsManager: SettingsManager;
	private scheduler: Scheduler;
	private ui: UIAssistant;
	private statistics: Statistics;

	async onload() {

		//#region 

		const data = await this.loadData(); // Returns `null` if file doesn't exist.		
		this.data = {
			...{},
			...{
				settings: { ...SettingsManager.DEFAULT_DATA, ...data?.settings || {} },
				data: { ...Statistics.DEFAULT_DATA, ...data?.data || {} }
			} satisfies PluginData
		};

		this.settingsManager = new SettingsManager(
			this.data.settings,
			async (_settings) => await this.savePluginData()
		);
		this.addSettingTab(new SettingTab(this, this.settingsManager));

		this.ui = new UIAssistant(this.settingsManager);

		this.statistics = new Statistics(this.data.data, async (data: StatisticsRoot) => {
			this.data.data = data;
			await this.savePluginData();
		});

		this.scheduler = new Scheduler(this.statistics);

		//#endregion

		this.app.workspace.onLayoutReady(() => this.registerEvents());

		this.registerMarkdownCodeBlockProcessor(
			DeclarationBlock.LANGUAGE,
			(source, el, _ctx) => DeclarationBlock.render(source, el),
			undefined);

		this.registerMarkdownCodeBlockProcessor(
			DeclarationBlock.LANGUAGE_SHORT,
			(source, el, _ctx) => DeclarationBlock.render(source, el),
			undefined);

		this.registerView(
			ReviewView.TYPE,
			(leaf) => new ReviewView(leaf, this.settingsManager, this.scheduler, this.ui)
		);

		this.addRibbonIcon(PLUGIN_ICON, this.ui.contextulize("Open review"), (evt: MouseEvent) => {
			this.openReviewView(Keymap.isModEvent(evt));
		}).addClass('come-through-ribbon-class');

		//#region Commands

		this.addCommand({
			id: 'open-review',
			name: 'Open review',
			callback: () => {
				this.openReviewView(true);
			},
		});

		//#endregion
	}

	onunload() { }

	private registerEvents() {

		this.registerEvent(this.app.metadataCache.on("changed", async (file, data, cache) => {
			const { ids, output } = FileParser.getAllIDsFromMetadata(file, data, cache, (id) => id.isFrontSide);				
			const editor = this.app.workspace.activeEditor?.editor;
			const autoGeneratedIDs = editor ? this.postProcessWithEditor(editor, output) : [];
			await this.syncIDs([... ids, ...autoGeneratedIDs] , file);
		}));
		
		this.registerEvent(this.app.workspace.on("file-open", async (file) => {			
			if (file) {				
				const { ids, output } = await FileParser.getAllIDsInFile(file, this.app, (id) => id.isFrontSide)
				const autoGeneratedIDs = await this.postProcessWithFile(file, output);
				await this.syncIDs([... ids, ...autoGeneratedIDs] , file);
			}
		}));

		this.registerEvent(this.app.vault.on("delete", async (file) => {
			if (file instanceof TFile && this.statistics.removeNote(asNoteID(file.path)))
				await this.statistics.save();
		}));

		this.registerEvent(this.app.vault.on("rename", async (file, oldPath) => {
			if (file instanceof TFile && this.statistics.changeNoteID(asNoteID(oldPath), asNoteID(file), false))
				await this.statistics.save();
		}));

		this.registerEvent(this.app.workspace.on("file-menu", (menu, file, source, _leaf) => {
			if (!(file instanceof TFile))
				return;

			const isFileIncluded = this.statistics.getNote(asNoteID(file)) ? true : false;

			if (isFileIncluded && (source === "file-explorer-context-menu" || source === "more-options" || source === "tab-header")) {
				this.ui.addMenuItem(menu, "View flashcard info", {
					onClick: async () => this.viewInfo(file)
				});
			}
		}));
	}

	private async savePluginData() {
		await this.saveData(this.data);
	}

	private async openReviewView(paneType: PaneType | boolean) {

		const leaf = this.app.workspace.getLeaf(paneType);

		await leaf.setViewState({
			type: ReviewView.TYPE,
			state: undefined,
			active: true,
			pinned: undefined,
			group: undefined,
		});
	}

	private async viewInfo(file: TFile) {

		const { ids } = await FileParser.getAllIDsInFile(file, this.app);

		let info: string = `${file.basename} defines ${ids.length} card sides\n\n`;
		info += ids.map(id => this.statistics.cardInfo(id)).join("\n\n");
		this.ui.displayNotice(info, { prefix: false, preventDismissal: true });
	}

	//#region 

	private async syncIDs(ids: FullID[], file: TFile) {
		try {
			this.statistics.syncData(ids, file.path, () => this.scheduler.newStatistics());
			await this.statistics.save();
		}
		catch (error) {			
			console.error("Failed to sync", error);
			this.ui.displayErrorNotice(`${(error instanceof Error) ? `An unexpected error occurred: ${error.message}` : "An unknown error occurred."}`);			
		}
	}

	private postProcessWithEditor(editor: Editor, postInfo: PostParseInfo): FullID[] {	
		if (postInfo.incompleteDeclarationInfos.length == 0)
			return [];

		const cursorPosition = editor.getCursor();	
		const autoGeneratedIDs: FullID[] = [];			
		
		for (const info of postInfo.incompleteDeclarationInfos) {
			const section = info.section;

			// Cursor is in section.
			if (cursorPosition.line >= section.position.start.line && 
					cursorPosition.line <= section.position.end.line)
					continue;
			
			const completeDeclaration = DeclarationBlock.ensureID(info.declaration);			
			if (completeDeclaration) {
				// This will trigger file changed events.
				editor.replaceRange(
					DeclarationBlock.toString(completeDeclaration),						
					{ line: section.position.start.line + 1, ch: 0},
					{ line: section.position.end.line, ch: 0 },
					undefined
				);

				autoGeneratedIDs.push(FullID.create(
					info.noteID, 
					completeDeclaration.id, 
					DeclarationBlock.isFrontSide(completeDeclaration)
				));
			}
		}
		
		return autoGeneratedIDs;
	}

	private async postProcessWithFile(file: TFile, postInfo: PostParseInfo): Promise<FullID[]> {	
		if (postInfo.incompleteDeclarationInfos.length == 0)
			return [];
				
		const autoGeneratedIDs: FullID[] = [];	
		
		for (const info of postInfo.incompleteDeclarationInfos) {			
			const completeDeclaration = DeclarationBlock.ensureID(info.declaration);			
			if (completeDeclaration) {				
				// This will trigger file changed events
				await this.app.vault.process(file, (data) => {
					return DeclarationBlock.replace(data, info.declaration, completeDeclaration);
				});

				autoGeneratedIDs.push(FullID.create(
					info.noteID, 
					completeDeclaration.id, 
					DeclarationBlock.isFrontSide(completeDeclaration)
				));
			}
		}
		
		return autoGeneratedIDs;
	}

	//#endregion
}
