import { DeckableDeclaration, DeclarationBase, DeclarationRange, YamlParseErrorCallback } from "declarations/Declaration";
import { UniqueID } from "UniqueID";

export const enum IDScope {
	UNIQUE,
	NOTE,
};

export type DeclarationSide = "front" | "back";
export interface DeclarationSpecification extends Omit<IncompleteDeclarationSpecification, 'side' | 'id'> {
	side: DeclarationSide;
	id: string;
}

/**
 * The minimum required propertes that need to be specified before
 * default values and/or generated values can be applied
 * to turn it into a {@link DeclarationSpecification}.
 */
export interface IncompleteDeclarationSpecification extends DeckableDeclaration {
	/** Side needs to be specfied. Only if "front" can an ID be auto generated. */
	side: string;
	id?: string;
}

const DeclarationInterfacePropertyName = {
	ID: "id",
	SIDE: "side",
};

export class CardDeclaration extends DeclarationBase implements DeclarationSpecification {

	public readonly id: string;
	public readonly side: DeclarationSide;

	public deckID: string | undefined;
	public readonly isAutoGenerated: boolean = false;
	public readonly idScope: IDScope;

	public constructor(id: string, side: DeclarationSide, idScope: IDScope, deckID: string | undefined = undefined, isAutoGenerated = false) {
		super();
		this.id = id;
		this.side = side.trim().toLowerCase() as DeclarationSide;
		this.idScope = idScope;
		this.deckID = deckID;
		this.isAutoGenerated = isAutoGenerated;
	}

	//#region

	/**
	 * @param source The code block including the three ticks at the beginning and end.
	 * @param onParseError
	 * @param incompleteCallback Invoked if content of {@link source} is recognized but is missing required properties.
	 * @returns `null` if this block is unknown or it contains invalid YAML.
	*/
	public static parseCodeBlock(
		source: string,
		onParseError?: YamlParseErrorCallback,
		incompleteCallback?: (incomplete: IncompleteDeclarationSpecification, position: DeclarationRange) => void) {

		const location = this.contentOfCodeBlock(source);
		if (!location)
			return null;

		const declaration = this.tryParseAsYaml(this.slice(source, location), onParseError);
		if (!declaration)
			return null;

		if (this.conformsToDeclarationSpecification(declaration))
			return new this(declaration.id, declaration.side, IDScope.UNIQUE, declaration.deckID);

		if (this.conformsToIncompleteDeclarationSpecification(declaration) && incompleteCallback)
			incompleteCallback(declaration, location);

		return null;
	}

	//#endregion

	//#region

	public static canComplete(decl: IncompleteDeclarationSpecification) {
		if (!this.conformsToIncompleteDeclarationSpecification(decl))
			return false;

		if (Object.hasOwn(decl, DeclarationInterfacePropertyName.ID) && this.isIDValid(decl.id))
			return false;

		if (!this.isFrontSide(decl))
			return false;

		return true;
	}

	/**
	 * Completes a {@link IncompleteDeclarationSpecification} by assigning default and generated values
	 * to non-required properties.
	 *
	 * @param decl
	 * @returns `null` if {@link canComplete} returns `false`.
	 */
	public static tryToComplete(decl: IncompleteDeclarationSpecification, preventIDs?: Set<string>) {
		if (!this.canComplete(decl))
			return null;

		const complete = {
			...decl,
			...{
				id: UniqueID.generateID(preventIDs)
			}
		} as DeclarationSpecification;

		return complete;
	}

	/**
	 * May use if already checked with {@link canComplete}.
	 * @param decl
	 * @returns Result of calling {@link tryToComplete}.
	 */
	public static completeOrThrow(decl: IncompleteDeclarationSpecification, preventIDs?: Set<string>) {
		const maybeCompleted = this.tryToComplete(decl, preventIDs);
		if (maybeCompleted === null)
			throw new Error("Could not complete given declaration block.");
		return maybeCompleted;
	}

	//#endregion

	//#region

	/**
	 * @returns `true` if {@link obj} conforms to {@link DeclarationSpecification}.
	 */
	public static conformsToDeclarationSpecification(obj: any): obj is DeclarationSpecification {
		return (
			typeof obj === 'object' && obj !== null &&
			this.validateSide(obj) &&
			this.isIDValid(obj.id)
		);
	}

	/**
	 * Check if {@link obj} conforms to {@link IncompleteDeclarationSpecification}.
	 * @param obj
	 * @returns `false` if {@link obj} is `null`.
	 */
	public static conformsToIncompleteDeclarationSpecification(obj: any): obj is IncompleteDeclarationSpecification {
		return (
			typeof obj === 'object' && obj !== null &&
			this.validateSide(obj)
		);
	}

	private static isIDValid(value?: any) {
		return typeof value === 'string' && UniqueID.isValid(<string>value);
	}

	private static validateSide(obj: Record<string, any>) {
		if (Object.hasOwn(obj, DeclarationInterfacePropertyName.SIDE)) {
			const value = obj[DeclarationInterfacePropertyName.SIDE];
			if (typeof value === 'string')
				return [...this.frontSideValues, ...this.backSideValues].includes((<string>value).trim().toLowerCase());
		}
		return false;
	}

	public static isFrontSide(d: DeclarationSpecification | IncompleteDeclarationSpecification, throwIfNotValid = false) {
		if (throwIfNotValid && !this.validateSide(d))
			throw new Error(`Side is not valid: ${d.side}`);
		return CardDeclaration.frontSideValues.includes(d.side);
	}

	public get isFrontSide() {
		return CardDeclaration.isFrontSide(this);
	}

	private static readonly frontSideValues = ["f", "front"];
	private static readonly backSideValues = ["b", "back"];

	//#endregion
}
