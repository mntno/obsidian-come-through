import { DeckModal } from "DeckModal";
import { DeclarationBlock, IncompleteDeclarationSpecification } from "DeclarationBlock";
import { FileParser, PostParseInfo } from "FileParser";
import { FullID } from "FullID";
import { asNoteID, fullIDFromDeclaration } from "TypeAssistant";
import { App, CachedMetadata, Component, Editor, MarkdownPostProcessorContext, MarkdownRenderChild, MarkdownSectionInformation, TFile, Vault } from "obsidian";
import { setIcon } from "obsidian";
import { DeckIDDataTuple, DataStore } from "DataStore";
import { PLUGIN_ICON, UIAssistant } from "UIAssistant";


export class DeclarationManager {

  //#region Complete Incomplete Declarations

  public static async processFile(file: TFile, app: App) {
    const { ids, output } = await FileParser.getAllIDsInFile(file, app, (id) => id.isFrontSide)
    const autoGeneratedIDs = await DeclarationManager.postProcessWithFile(app, file, output);
    return [...ids, ...autoGeneratedIDs];
  }

  public static async processFileChanged(file: TFile, fileContent: string, cache: CachedMetadata, app: App) {
    const { ids, output } = FileParser.getAllIDsFromMetadata(asNoteID(file), fileContent, cache, (id) => id.isFrontSide);
    const editor = app.workspace.activeEditor?.editor;
    const autoGeneratedIDs = editor ? this.postProcessWithEditor(editor, output) : [];
    return [...ids, ...autoGeneratedIDs];
  }

  /**
   * This method and {@link postProcessWithFile} goes through all incomplete declarations
   * in {@link postInfo} that can be completed and completes them, modifying the file 
   * in the process. The returned values were modified and needs to be saved to persistant storage.
   * 
   * This method is preferred to {@link postProcessWithFile} when the file can be modified via an 
   * {@link Editor} instance.
   * 
   * @param editor 
   * @param postInfo 
   * @returns 
   */
  private static postProcessWithEditor(editor: Editor, postInfo: PostParseInfo): FullID[] {
    const replacementDeclarationInfos = postInfo.incompleteDeclarationInfos
      .filter(info => DeclarationBlock.canComplete(info.declaration));

    if (replacementDeclarationInfos.length == 0)
      return [];

    const cursorPosition = editor.getCursor(); // Do not modify the section if the cursor is there.
    const autoGeneratedIDs: FullID[] = [];
    const existingIDs = new Set<string>();

    let diff = 0;
    for (const info of replacementDeclarationInfos) {

      const startOffsetBeforeModification = info.section.position.start.offset + diff;
      const endOffsetBeforeModification = info.section.position.end.offset + diff;
      const startPosBeforeModification = editor.offsetToPos(startOffsetBeforeModification);
      const endPosBeforeModification = editor.offsetToPos(endOffsetBeforeModification);

      // Cursor is in section.
      if (cursorPosition.line >= startPosBeforeModification.line &&
        cursorPosition.line <= endPosBeforeModification.line)
        continue;

      const completeDeclaration = DeclarationBlock.completeOrThrow(info.declaration, existingIDs);
      const replacement = DeclarationBlock.toString(completeDeclaration);

      // This will trigger file changed events.
      editor.replaceRange(
        replacement,
        editor.offsetToPos(info.section.position.start.offset + info.location.start + diff),
        { line: endPosBeforeModification.line, ch: 0 },
        undefined
      );

      existingIDs.add(completeDeclaration.id);
      autoGeneratedIDs.push(FullID.create(
        info.noteID,
        completeDeclaration.id,
        DeclarationBlock.isFrontSide(completeDeclaration)
      ));

      diff += replacement.length - (info.location.end - info.location.start);
    }

    return autoGeneratedIDs;
  }

  /**
   * See {@link postProcessWithEditor}.
   * 
   * @param app 
   * @param file 
   * @param postInfo 
   * @returns 
   */
  private static async postProcessWithFile(app: App, file: TFile, postInfo: PostParseInfo): Promise<FullID[]> {
    const replacementDeclarationInfos = postInfo.incompleteDeclarationInfos
      .filter(info => DeclarationBlock.canComplete(info.declaration));

    if (replacementDeclarationInfos.length == 0)
      return [];

    const autoGeneratedIDs: FullID[] = [];
    const existingIDs = new Set<string>();

    // This will trigger file changed events
    await app.vault.process(file, (data) => {

      const parts: string[] = [];

      let sliceStartIndex = 0;
      for (const info of replacementDeclarationInfos) {

        const startOffset = info.section.position.start.offset + info.location.start;
        const replace = DeclarationBlock.toString(info.declaration);
        const completeDeclaration = DeclarationBlock.completeOrThrow(info.declaration, existingIDs);
        const replacement = DeclarationBlock.toString(completeDeclaration);

        parts.push(data.slice(sliceStartIndex, startOffset));
        parts.push(replacement);
        sliceStartIndex = startOffset + replace.length;

        existingIDs.add(completeDeclaration.id);
        autoGeneratedIDs.push(FullID.create(
          info.noteID,
          completeDeclaration.id,
          DeclarationBlock.isFrontSide(completeDeclaration)
        ));
      }
      parts.push(data.slice(sliceStartIndex));

      return parts.join(""); // If [separator is] omitted, the array elements are separated with a comma.
    });

    return autoGeneratedIDs;
  }

  //#endregion

  //#region 

  public static async processCodeBlock(
    app: App,
    source: string,
    el: HTMLElement,
    ctx: MarkdownPostProcessorContext,
    data: DataStore) {

    const component = new MarkdownRenderChild(el);
    ctx.addChild(component);

    el.addClass("callout");
    const titleContainer = el.createDiv({ cls: "callout-title" });
    titleContainer.createDiv({ cls: "callout-icon" }, (icon) => setIcon(icon, PLUGIN_ICON));
    titleContainer.createDiv({ cls: "callout-title-inner", text: "Flashcard Declaration" });
    const contentContainer = el.createDiv({ cls: "callout-content" });

    //#region Error handling
    const declarationError = (message?: string) => {
      el.addClass("error");
      titleContainer.addClass("error");
      if (message !== undefined)
        contentContainer.createEl("p", { text: message });
    }

    const declaration = DeclarationBlock.tryParseAsYaml(source, (error) => {
      declarationError(`Please check for the following:`);
      contentContainer.createEl("ul", {}, (el) => {
        el.createEl("li", { text: "Missing or misplaced colons after keys (e.g., `side front` instead of `side: front`)."})
        el.createEl("li", { text: "Incorrect spacing around colons (e.g., `side:front` instead of `side: front`)."})
        el.createEl("li", { text: "Pay close attention to how the information is indented. Sometimes, the alignment of the text matters."})              
      });
      contentContainer.createEl("p", { text: `Specific details: ${error.message}` });
    });

    if (declaration === null)
      return
    
    if (!DeclarationBlock.conformsToIncompleteDeclarationSpecification(declaration)) {
      declarationError("Incomplete card declaration.");
      return;
    }
    //#endregion

    this.renderDeclaration(
      declaration, 
      contentContainer, 
      data.getAllDecks(), 
      component, async (type, selectEl) => {
      
      const processChange = async (changedDeclaration: IncompleteDeclarationSpecification) =>
        await this.onDeclarationChanged(app, el, ctx, data, declaration, changedDeclaration);

      if (type === "deckAdded") {
        DeckModal.add(app, data, async (addedDeck) => {
          // Add a new option for the created deck
          selectEl.createEl("option", {
            text: addedDeck.data.n,
            value: addedDeck.id,
          }, (el) => {
            el.selected = true;
          });
          await processChange(DeclarationBlock.copyWithDeck(declaration, addedDeck.id));
        });
      }
      else if (type === "deckChanged") {
        const selectedDeckID = selectEl.value ? selectEl.value : undefined;
        if (selectedDeckID !== declaration.deckID)
          await processChange(DeclarationBlock.copyWithDeck(declaration, selectedDeckID));
      }
    });
  }

  private static async onDeclarationChanged(
    app: App,
    el: HTMLElement,
    ctx: MarkdownPostProcessorContext,
    data: DataStore,
    oldDeclaration: IncompleteDeclarationSpecification,
    changedDeclaration: IncompleteDeclarationSpecification) {
    
    const file = app.vault.getFileByPath(ctx.sourcePath);
    if (!file)
      return;
    
    // Only update persistant store if valid.
    if (DeclarationBlock.conformsToDeclarationSpecification(oldDeclaration)) {
      const fullID = fullIDFromDeclaration(oldDeclaration, asNoteID(file.path));
      
      if (oldDeclaration.deckID !== changedDeclaration.deckID) {
        data.editCard(fullID, (editor) => {      
          editor.setDeck(changedDeclaration.deckID);
          return true;
        });
      }
      
      await data.save();
    }
    
    await this.processSection(
      app.vault,
      file,
      () => ctx.getSectionInfo(el),
      () => DeclarationBlock.toString(changedDeclaration)
    );
  }

  private static renderDeclaration(
    declaration: IncompleteDeclarationSpecification,
    contentContainer: HTMLElement,
    decks: DeckIDDataTuple[],
    component: Component,
    onClick: (buttonType: "deckAdded" | "deckChanged", selectEl: HTMLSelectElement) => void) {

    const table = contentContainer.createEl("table");
    const body = table.createEl("tbody");

    const rowID = body.createEl("tr");
    rowID.createEl("td", { text: "ID" });
    rowID.createEl("td", { text: declaration.id });

    const rowSide = body.createEl("tr");
    rowSide.createEl("td", { text: "Side" });
    rowSide.createEl("td", { text: `${DeclarationBlock.isFrontSide(declaration) ? "Front" : "Back"}` });

    if (DeclarationBlock.isFrontSide(declaration)) {

      const rowDeck = body.createEl("tr");
      rowDeck.createEl("td", { text: "Deck" });
      const tdDropdown = rowDeck.createEl("td", { cls: "select-deck-cell" });

      const deckSelectEl = tdDropdown.createEl("select", { cls: "dropdown" }, (el) => {
        el.createEl("option", {
          text: "None",
          value: UIAssistant.DECK_ID_UNDEFINED,
        });
      });

      // Add new deck button
      tdDropdown.createEl("button", {}, (button) => {
        setIcon(button, "plus");
        component.registerDomEvent(button, "click", () => onClick("deckAdded", deckSelectEl));
      });

      // Deck selector
      if (decks.length > 0) {
        decks.forEach(deck => {
          deckSelectEl.createEl("option", {
            text: deck.data.n,
            value: deck.id,
          }, (el) => {
            el.selected = declaration?.deckID === deck.id;
          });
        });
        component.registerDomEvent(deckSelectEl, "change", () => onClick("deckChanged", deckSelectEl));
      }
    }
  }

  //#endregion

  //#region Helpers

  /**
   * Overwrites the section returned from {@link getInfo} with value returned from {@link getSectionContent}.
   * @param vault 
   * @param file 
   * @param getInfo 
   * @param getSectionContent  
   */
  private static async processSection(
    vault: Vault,
    file: TFile,
    getInfo: () => MarkdownSectionInformation | null,
    getSectionContent: () => string) {

    await vault.process(file, (data) => {
      const info = getInfo();
      if (!info)
        return data;

      const startIndex = this.getIndexUpToLine(data, info.lineStart + 1);
      const endIndex = this.getIndexUpToLine(data, info.lineEnd);

      console.assert(startIndex >= 0);
      console.assert(endIndex >= 0);

      const before = data.slice(0, startIndex);
      const declarationString = getSectionContent();
      const after = data.slice(endIndex);

      return before + declarationString + after;
    });
  }

  /**
   * 
   * @param source String to search.
   * @param lineNumber Line number to return the index for.
   * @returns 
   */
  private static getIndexUpToLine(source: string, lineNumber: number): number {
    if (lineNumber === 0)
      return 0;

    let currentIndex = 0;
    let lineCount = 0;
    let previousNewlineIndex = -1;

    while (lineCount < lineNumber) {
      const newlineIndex = source.indexOf('\n', currentIndex);
      if (newlineIndex === -1)
        return -1;

      previousNewlineIndex = newlineIndex;
      currentIndex = newlineIndex + 1;
      lineCount++;
    }

    return previousNewlineIndex + 1;
  }

  //#endregion
}