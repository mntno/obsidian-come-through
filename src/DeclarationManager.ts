import { DeckModal } from "modals/DeckModal";
import { CardDeclaration } from "declarations/CardDeclaration";
import { FileParser, PostParseInfo } from "FileParser";
import { FullID } from "FullID";
import { asNoteID } from "TypeAssistant";
import { App, CachedMetadata, Editor, MarkdownPostProcessorContext, MarkdownSectionInformation, TFile, Vault } from "obsidian";
import { DataStore } from "DataStore";
import { DeclarationRenderer } from "declarations/DeclarationRenderer";
import { DeckableDeclaration, DeclarationBase } from "declarations/Declaration";


export class DeclarationManager {

	//#region Complete Incomplete Declarations

	public static async processFile(file: TFile, app: App) {
		const { ids, output } = await FileParser.getAllIDsInFile(file, app, (id) => id.isFrontSide)
		const autoGeneratedIDs = await DeclarationManager.postProcessWithFile(app, file, output);
		return [...ids, ...autoGeneratedIDs];
	}

	public static async processFileChanged(file: TFile, fileContent: string, cache: CachedMetadata, app: App) {
		const { ids, output } = FileParser.getAllIDsFromMetadata(asNoteID(file), fileContent, cache, (id) => id.isFrontSide);
		const editor = app.workspace.activeEditor?.editor;
		const autoGeneratedIDs = editor ? this.postProcessWithEditor(editor, output) : [];
		return [...ids, ...autoGeneratedIDs];
	}

	/**
	 * This method and {@link postProcessWithFile} goes through all incomplete declarations
	 * in {@link postInfo} that can be completed and completes them, modifying the file
	 * in the process. The returned values were modified and needs to be saved to persistant storage.
	 *
	 * This method is preferred to {@link postProcessWithFile} when the file can be modified via an
	 * {@link Editor} instance.
	 *
	 * @param editor
	 * @param postInfo
	 * @returns
	 */
	private static postProcessWithEditor(editor: Editor, postInfo: PostParseInfo): FullID[] {
		const replacementDeclarationInfos = postInfo.incompleteDeclarationInfos
			.filter(info => CardDeclaration.canComplete(info.declaration));

		if (replacementDeclarationInfos.length == 0)
			return [];

		const cursorPosition = editor.getCursor(); // Do not modify the section if the cursor is there.
		const autoGeneratedIDs: FullID[] = [];
		const existingIDs = new Set<string>();

		let diff = 0;
		for (const info of replacementDeclarationInfos) {

			const startOffsetBeforeModification = info.section.position.start.offset + diff;
			const endOffsetBeforeModification = info.section.position.end.offset + diff;
			const startPosBeforeModification = editor.offsetToPos(startOffsetBeforeModification);
			const endPosBeforeModification = editor.offsetToPos(endOffsetBeforeModification);

			// Cursor is in section.
			if (cursorPosition.line >= startPosBeforeModification.line &&
				cursorPosition.line <= endPosBeforeModification.line)
				continue;

			const completeDeclaration = CardDeclaration.completeOrThrow(info.declaration, existingIDs);
			const replacement = CardDeclaration.toString(completeDeclaration);

			// This will trigger file changed events.
			editor.replaceRange(
				replacement,
				editor.offsetToPos(info.section.position.start.offset + info.location.start + diff),
				{ line: endPosBeforeModification.line, ch: 0 },
				undefined
			);

			existingIDs.add(completeDeclaration.id);
			autoGeneratedIDs.push(FullID.create(
				info.noteID,
				completeDeclaration.id,
				CardDeclaration.isFrontSide(completeDeclaration)
			));

			diff += replacement.length - (info.location.end - info.location.start);
		}

		return autoGeneratedIDs;
	}

	/**
	 * See {@link postProcessWithEditor}.
	 *
	 * @param app
	 * @param file
	 * @param postInfo
	 * @returns
	 */
	private static async postProcessWithFile(app: App, file: TFile, postInfo: PostParseInfo): Promise<FullID[]> {
		const replacementDeclarationInfos = postInfo.incompleteDeclarationInfos
			.filter(info => CardDeclaration.canComplete(info.declaration));

		if (replacementDeclarationInfos.length == 0)
			return [];

		const autoGeneratedIDs: FullID[] = [];
		const existingIDs = new Set<string>();

		// This will trigger file changed events
		await app.vault.process(file, (data) => {

			const parts: string[] = [];

			let sliceStartIndex = 0;
			for (const info of replacementDeclarationInfos) {

				const startOffset = info.section.position.start.offset + info.location.start;
				const replace = CardDeclaration.toString(info.declaration);
				const completeDeclaration = CardDeclaration.completeOrThrow(info.declaration, existingIDs);
				const replacement = CardDeclaration.toString(completeDeclaration);

				parts.push(data.slice(sliceStartIndex, startOffset));
				parts.push(replacement);
				sliceStartIndex = startOffset + replace.length;

				existingIDs.add(completeDeclaration.id);
				autoGeneratedIDs.push(FullID.create(
					info.noteID,
					completeDeclaration.id,
					CardDeclaration.isFrontSide(completeDeclaration)
				));
			}
			parts.push(data.slice(sliceStartIndex));

			return parts.join(""); // If [separator is] omitted, the array elements are separated with a comma.
		});

		return autoGeneratedIDs;
	}

	//#endregion

	//#region

	public static async processCodeBlock(
		app: App,
		source: string,
		el: HTMLElement,
		ctx: MarkdownPostProcessorContext,
		data: DataStore) {

		const renderer = new DeclarationRenderer(el, source, {
			getAllDecks: () => data.getAllDecks()
		});
		ctx.addChild(renderer);

		const handleChangedDeclaration = async (
			changedDeclaration: DeckableDeclaration,
			file: TFile) => {

			await this.processSection(
				app.vault,
				file,
				() => ctx.getSectionInfo(el),
				() => DeclarationBase.toString(changedDeclaration)
			);
		}

		renderer.render((declaration, type, deckSelectEl) => {

			const file = app.vault.getFileByPath(ctx.sourcePath);
			console.assert(file);
			if (!file)
				return;

			if (type === "deckAdded") {
				DeckModal.add(app, data, async (addedDeck) => {

					// Add a new option for the created deck
					deckSelectEl.createEl("option", {
						text: addedDeck.data.n,
						value: addedDeck.id,
					}, (el) => {
						el.selected = true;
					});

					handleChangedDeclaration(
						CardDeclaration.copyWithDeck(declaration, addedDeck.id),
						file
					).catch(console.error);
				});
			}
			else if (type === "deckChanged") {

				const selectedDeckID = deckSelectEl.value ? deckSelectEl.value : undefined;
				if (selectedDeckID === declaration.deckID)
					return;

				handleChangedDeclaration(
					CardDeclaration.copyWithDeck(declaration, selectedDeckID),
					file
				).catch(console.error);
			}
		});
	}

	//#endregion

	//#region Helpers

	/**
	 * Overwrites the section returned from {@link getInfo} with value returned from {@link getSectionContent}.
	 * @param vault
	 * @param file
	 * @param getInfo
	 * @param getSectionContent
	 */
	private static async processSection(
		vault: Vault,
		file: TFile,
		getInfo: () => MarkdownSectionInformation | null,
		getSectionContent: () => string) {

		await vault.process(file, (data) => {
			const info = getInfo();
			if (!info)
				return data;

			const startIndex = this.getIndexUpToLine(data, info.lineStart + 1);
			const endIndex = this.getIndexUpToLine(data, info.lineEnd);

			console.assert(startIndex >= 0);
			console.assert(endIndex >= 0);

			const before = data.slice(0, startIndex);
			const declarationString = getSectionContent();
			const after = data.slice(endIndex);

			return before + declarationString + after;
		});
	}

	/**
	 *
	 * @param source String to search.
	 * @param lineNumber Line number to return the index for.
	 * @returns
	 */
	private static getIndexUpToLine(source: string, lineNumber: number): number {
		if (lineNumber === 0)
			return 0;

		let currentIndex = 0;
		let lineCount = 0;
		let previousNewlineIndex = -1;

		while (lineCount < lineNumber) {
			const newlineIndex = source.indexOf('\n', currentIndex);
			if (newlineIndex === -1)
				return -1;

			previousNewlineIndex = newlineIndex;
			currentIndex = newlineIndex + 1;
			lineCount++;
		}

		return previousNewlineIndex + 1;
	}

	//#endregion
}
