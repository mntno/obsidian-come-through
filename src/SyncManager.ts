import { CardDeclaration } from "declarations/CardDeclaration";
import { FullID } from "FullID";
import { asNoteID } from "TypeAssistant";
import { App, CachedMetadata, Editor, TAbstractFile, TFile } from "obsidian";
import { DeclarationParser, PostParseInfo } from "declarations/DeclarationParser";
import { DataStore, StatisticsData } from "DataStore";


export class SyncManager {

	public readonly app: App;
	private readonly dataStore: DataStore;
	private readonly statisticsFactory: () => StatisticsData;

	public constructor(dataStore: DataStore, app: App, statisticsFactory: () => StatisticsData) {
		this.dataStore = dataStore;
		this.app = app;
		this.statisticsFactory = statisticsFactory;
	}

	public async open(file: TFile | null) {
		if (file) {
			const ids = await SyncManager.processFile(file, this.app);
			await this.syncIDs(ids, file);
		}
	}

	public async changed(file: TFile, data: string, cache: CachedMetadata) {
		const ids = await SyncManager.processFileChanged(file, data, cache, this.app);
		await this.syncIDs(ids, file);
	}

	public async delete(file: TAbstractFile) {
		if (file instanceof TFile && this.dataStore.removeNote(asNoteID(file.path)))
			await this.dataStore.save();
	}

	public async rename(file: TAbstractFile, oldPath: string) {
		if (file instanceof TFile && this.dataStore.changeNoteID(asNoteID(oldPath), asNoteID(file), false))
			await this.dataStore.save();
	}

	private static async processFile(file: TFile, app: App) {
		const { ids, output } = await DeclarationParser.getAllIDsInFile(file, app, (id) => id.isFrontSide)
		const autoGeneratedIDs = await this.postProcessWithFile(app, file, output);
		return [...ids, ...autoGeneratedIDs];
	}

	private static async processFileChanged(file: TFile, fileContent: string, cache: CachedMetadata, app: App) {
		const { ids, output } = DeclarationParser.getAllIDsFromMetadata(asNoteID(file), fileContent, cache, (id) => id.isFrontSide);
		const editor = app.workspace.activeEditor?.editor;
		const autoGeneratedIDs = editor ? this.postProcessWithEditor(editor, output) : [];
		return [...ids, ...autoGeneratedIDs];
	}

	/**
	 * This method and {@link postProcessWithFile} goes through all incomplete declarations
	 * in {@link postInfo} that can be completed and completes them, modifying the file
	 * in the process. The returned values were modified and needs to be saved to persistant storage.
	 *
	 * This method is preferred to {@link postProcessWithFile} when the file can be modified via an
	 * {@link Editor} instance.
	 *
	 * @param editor
	 * @param postInfo
	 * @returns
	 */
	private static postProcessWithEditor(editor: Editor, postInfo: PostParseInfo): FullID[] {
		const replacementDeclarationInfos = postInfo.incompleteDeclarationInfos
			.filter(info => CardDeclaration.canComplete(info.declaration));

		if (replacementDeclarationInfos.length == 0)
			return [];

		const cursorPosition = editor.getCursor(); // Do not modify the section if the cursor is there.
		const autoGeneratedIDs: FullID[] = [];
		const existingIDs = new Set<string>();

		let diff = 0;
		for (const info of replacementDeclarationInfos) {

			const startOffsetBeforeModification = info.section.position.start.offset + diff;
			const endOffsetBeforeModification = info.section.position.end.offset + diff;
			const startPosBeforeModification = editor.offsetToPos(startOffsetBeforeModification);
			const endPosBeforeModification = editor.offsetToPos(endOffsetBeforeModification);

			// Cursor is in section.
			if (cursorPosition.line >= startPosBeforeModification.line &&
				cursorPosition.line <= endPosBeforeModification.line)
				continue;

			const completeDeclaration = CardDeclaration.completeOrThrow(info.declaration, existingIDs);
			const replacement = CardDeclaration.toString(completeDeclaration);

			// This will trigger file changed events.
			editor.replaceRange(
				replacement,
				editor.offsetToPos(info.section.position.start.offset + info.location.start + diff),
				{ line: endPosBeforeModification.line, ch: 0 },
				undefined
			);

			existingIDs.add(completeDeclaration.id);
			autoGeneratedIDs.push(FullID.create(
				info.noteID,
				completeDeclaration.id,
				CardDeclaration.isFrontSide(completeDeclaration)
			));

			diff += replacement.length - (info.location.end - info.location.start);
		}

		return autoGeneratedIDs;
	}

	/**
	 * See {@link postProcessWithEditor}.
	 *
	 * @param app
	 * @param file
	 * @param postInfo
	 * @returns
	 */
	private static async postProcessWithFile(app: App, file: TFile, postInfo: PostParseInfo): Promise<FullID[]> {
		const replacementDeclarationInfos = postInfo.incompleteDeclarationInfos
			.filter(info => CardDeclaration.canComplete(info.declaration));

		if (replacementDeclarationInfos.length == 0)
			return [];

		const autoGeneratedIDs: FullID[] = [];
		const existingIDs = new Set<string>();

		// This will trigger file changed events
		await app.vault.process(file, (data) => {

			const parts: string[] = [];

			let sliceStartIndex = 0;
			for (const info of replacementDeclarationInfos) {

				const startOffset = info.section.position.start.offset + info.location.start;
				const replace = CardDeclaration.toString(info.declaration);
				const completeDeclaration = CardDeclaration.completeOrThrow(info.declaration, existingIDs);
				const replacement = CardDeclaration.toString(completeDeclaration);

				parts.push(data.slice(sliceStartIndex, startOffset));
				parts.push(replacement);
				sliceStartIndex = startOffset + replace.length;

				existingIDs.add(completeDeclaration.id);
				autoGeneratedIDs.push(FullID.create(
					info.noteID,
					completeDeclaration.id,
					CardDeclaration.isFrontSide(completeDeclaration)
				));
			}
			parts.push(data.slice(sliceStartIndex));

			return parts.join(""); // If [separator is] omitted, the array elements are separated with a comma.
		});

		return autoGeneratedIDs;
	}

	private async syncIDs(ids: FullID[], file: TFile) {
		try {
			this.dataStore.syncData(ids, file.path, this.statisticsFactory);
			await this.dataStore.save();
		}
		catch (error) {
			console.error("Failed to sync", error);
			//this.ui.displayErrorNotice(`${(error instanceof Error) ? `Persisting changes failed: ${error.message}` : "An unknown error occurred while persisting changes."}`);
		}
	}
}
