import { DataStore, StatisticsData } from "DataStore";
import { CardDeclarable, CardDeclarationAssistant } from "declarations/CardDeclaration";
import { DeclarationInfo, DeclarationParser, PostParseInfo } from "declarations/DeclarationParser";
import { FullID, NoteID } from "FullID";
import { App, CachedMetadata, Editor, FileManager, TAbstractFile, TFile } from "obsidian";
import { asNoteID, isString } from "TypeAssistant";


export class SyncManager {

	public readonly app: App;
	private readonly dataStore: DataStore;
	private readonly statisticsFactory: () => StatisticsData;
	private isDisabled = false;

	public constructor(dataStore: DataStore, app: App, statisticsFactory: () => StatisticsData) {
		this.dataStore = dataStore;
		this.app = app;
		this.statisticsFactory = statisticsFactory;
	}

	public setDisabled() {
		this.isDisabled = true;
	}

	public setEnabled() {
		this.isDisabled = false;
	}

	public async open(file: TFile | null) {
		if (this.isDisabled)
			return;

		if (file) {
			const ids = await SyncManager.processFile(file, this.app);
			await this.syncIDs(ids, file);
		}
	}

	public async changed(file: TFile, data: string, cache: CachedMetadata) {
		if (this.isDisabled)
			return;

		const ids = await SyncManager.processFileChanged(file, data, cache, this.app);
		await this.syncIDs(ids, file);
	}

	public async delete(file: TAbstractFile) {
		if (this.isDisabled)
			return;

		if (file instanceof TFile && this.dataStore.removeNote(asNoteID(file.path)))
			await this.dataStore.save();
	}

	public async rename(file: TAbstractFile, oldPath: string) {
		if (this.isDisabled)
			return;

		if (file instanceof TFile && this.dataStore.changeNoteID(asNoteID(oldPath), asNoteID(file), false))
			await this.dataStore.save();
	}

	private static async processFile(file: TFile, app: App) {
		const { ids, output } = await DeclarationParser.getAllIDsInFile(file, app, (id) => id.isFrontSide)
		const autoGeneratedIDs = await this.postProcessWithFile(app, file, output);
		return [...ids, ...autoGeneratedIDs];
	}

	private static async processFileChanged(file: TFile, fileContent: string, cache: CachedMetadata, app: App) {
		const { ids, output } = DeclarationParser.getAllIDsFromMetadata(asNoteID(file), fileContent, cache, (id) => id.isFrontSide);
		const editor = app.workspace.activeEditor?.editor;
		const autoGeneratedIDs = editor ? await this.postProcessWithEditor(editor, output, file, app.fileManager) : [];
		return [...ids, ...autoGeneratedIDs];
	}

	/**
		* This method and {@link postProcessWithFile} goes through all defaultable/incomplete declarations
		*	(those whose empty keys can be assigned default values, such as a generated id)
		* in {@link postInfo} that can be assigned default values and does so, modifying the file
		* in the process.
		*
		* The returned values are the {@link FullID}s of those declarations that were completed
		* and therefore also need to be saved to persistant storage.
		*
		* This method is preferred to {@link postProcessWithFile} when the file can be modified via an
		* {@link Editor} instance.
		*
		* @param editor
		* @param postInfo
		* @returns IDs of declarations that this method was able to make valid.
		*/
	private static async postProcessWithEditor(editor: Editor, postInfo: PostParseInfo, file: TFile, fileManager: FileManager): Promise<FullID[]> {
		const replacementDeclarationInfos = SyncManager.getFrontSideInvalidDeclarations(postInfo);
		if (replacementDeclarationInfos.length == 0)
			return [];

		const cursorPosition = editor.getCursor(); // Do not modify the section if the cursor is there.
		const autoGeneratedIDs: FullID[] = [];
		const existingIDs = new Set<string>();

		let diff = 0;
		for (const info of replacementDeclarationInfos) {
			const completeDeclarationFromFrontmatter = await SyncManager.processFrontmatter(file, fileManager, info, existingIDs);
			if (completeDeclarationFromFrontmatter) {
				SyncManager.createAndAddIDFromDeclarable(autoGeneratedIDs, completeDeclarationFromFrontmatter, info.noteID, existingIDs);
				continue; // This declaration done, go to next.
			}

			const startOffsetBeforeModification = info.section.position.start.offset + diff;
			const endOffsetBeforeModification = info.section.position.end.offset + diff;
			const startPosBeforeModification = editor.offsetToPos(startOffsetBeforeModification);
			const endPosBeforeModification = editor.offsetToPos(endOffsetBeforeModification);

			// Cursor is in section.
			if (cursorPosition.line >= startPosBeforeModification.line &&
				cursorPosition.line <= endPosBeforeModification.line)
				continue;

			const completeDeclaration = CardDeclarationAssistant.makeValidOrThrow(info.declaration, existingIDs);
			const replacement = CardDeclarationAssistant.toString(completeDeclaration);

			// This will trigger file changed events.
			editor.replaceRange(
				replacement,
				editor.offsetToPos(info.section.position.start.offset + info.location.start + diff),
				{ line: endPosBeforeModification.line, ch: 0 },
				undefined
			);

			existingIDs.add(completeDeclaration.id);
			autoGeneratedIDs.push(FullID.create(
				info.noteID,
				completeDeclaration.id,
				CardDeclarationAssistant.isFrontSide(completeDeclaration)
			));

			diff += replacement.length - (info.location.end - info.location.start);
		}

		return autoGeneratedIDs;
	}

	/**
	 * See {@link postProcessWithEditor}.
	 *
	 * @param app
	 * @param file
	 * @param postInfo
	 * @returns
	 */
	private static async postProcessWithFile(app: App, file: TFile, postInfo: PostParseInfo): Promise<FullID[]> {
		const replacementDeclarationInfos = SyncManager.getFrontSideInvalidDeclarations(postInfo);
		if (replacementDeclarationInfos.length == 0)
			return [];

		const autoGeneratedIDs: FullID[] = [];
		const existingIDs = new Set<string>();
		for (const info of replacementDeclarationInfos) {
			const completeDeclarationFromFrontmatter = await SyncManager.processFrontmatter(file, app.fileManager, info, existingIDs);
			if (completeDeclarationFromFrontmatter) {
				this.createAndAddIDFromDeclarable(autoGeneratedIDs, completeDeclarationFromFrontmatter, info.noteID, existingIDs);
				replacementDeclarationInfos.remove(info); // Remove this one so it doesn't get processed again below.
			}
		}
		if (replacementDeclarationInfos.length == 0)
			return [];

		// This will trigger file changed events
		await app.vault.process(file, (data) => {

			const parts: string[] = [];

			let sliceStartIndex = 0;
			for (const info of replacementDeclarationInfos) {

				const startOffset = info.section.position.start.offset + info.location.start;
				const replace = CardDeclarationAssistant.toString(info.declaration);
				const completeDeclaration = CardDeclarationAssistant.makeValidOrThrow(info.declaration, existingIDs);
				const replacement = CardDeclarationAssistant.toString(completeDeclaration);

				parts.push(data.slice(sliceStartIndex, startOffset));
				parts.push(replacement);
				sliceStartIndex = startOffset + replace.length;

				SyncManager.createAndAddIDFromDeclarable(autoGeneratedIDs, completeDeclaration, info.noteID, existingIDs);
			}
			parts.push(data.slice(sliceStartIndex));

			return parts.join(""); // If [separator is] omitted, the array elements are separated with a comma.
		});

		return autoGeneratedIDs;
	}

	/**
		* {@link PostParseInfo.incompleteDeclarationInfos} should contain {@link DeclarationInfo}s
		* that can be represented as statistics items and persisted in disk if some missing values are filled in.
		*
		* This method filters out declarations that should not be persisted.
		* @param postInfo As populated by {@link DeclarationParser.getAllIDsInFile} or {@link DeclarationParser.getAllIDsFromMetadata}.
		* @returns
		*/
	private static getFrontSideInvalidDeclarations(postInfo: PostParseInfo) {
		const declarations = postInfo.incompleteDeclarationInfos
			.filter(info => (
				CardDeclarationAssistant.canMakeValidCardDeclarable(info.declaration) &&
				CardDeclarationAssistant.isFrontSide(info.declaration))
			);
		console.assert(postInfo.incompleteDeclarationInfos.length == declarations.length, "Hmm")
		return declarations;
	}

	private static createAndAddIDFromDeclarable(ids: FullID[], declarable: CardDeclarable, noteID: NoteID, existingIDs: Set<string>) {
		existingIDs.add(declarable.id);
		ids.push(FullID.create(
			noteID,
			declarable.id,
			CardDeclarationAssistant.isFrontSide(declarable)
		));
	}

	/**
		* If {@link info} refers to a declaration within the frontmatter, this method first
		* makes it valid/complete, updates the frontmatter, then returns the valid declaration.
		* @param file The file containing the frontmatter referred to by {@link info}.
		* @param fileManager Used to modify the declaration in the frontmatter if needed.
		* @param info Referring to an invalid declaration (method will assert and return `null` if declaration is already valid).
		* @param preventIDs IDs to not generate if an ID needs to be generated for the declaration found in {@link info}.
		* @returns Declarable found in {@link info} or `null` if none found.
		*/
	private static async processFrontmatter(file: TFile, fileManager: FileManager, info: DeclarationInfo, preventIDs: Set<string>) {
		let completeDeclaration: CardDeclarable | null = null;

		if (DeclarationParser.isExternalSectionCache(info.section) && info.section.externalType === "frontmatter") {
			if (CardDeclarationAssistant.isValidCardDeclarable(info.declaration)) {
				console.assert(false, "Expected an invalid declaration.");
				completeDeclaration = null; // info.declaration;
			}
			else {
				// Set default values and modify the file.
				completeDeclaration = CardDeclarationAssistant.makeValidOrThrow(info.declaration, preventIDs);
				const key = info.section.id;
				if (isString(key)) {
					// This seems to work fine while cursor is in the frontmatter (so no need to skip this declaration now because of that).
					await fileManager.processFrontMatter(file, (fm) => fm[key] = completeDeclaration).catch(console.error);
				}
				else {
					console.assert(key, "Expected section id to be set to the frontmatter YAML key assinged to the declaration.");
				}
			}
		}

		return completeDeclaration;
	}

	private async syncIDs(ids: FullID[], file: TFile) {
		if (this.isDisabled)
			return;

		try {
			this.dataStore.syncData(ids, file.path, this.statisticsFactory);
			await this.dataStore.save();
		}
		catch (error) {
			console.error("Failed to sync", error);
			//this.ui.displayErrorNotice(`${(error instanceof Error) ? `Persisting changes failed: ${error.message}` : "An unknown error occurred while persisting changes."}`);
		}
	}
}
